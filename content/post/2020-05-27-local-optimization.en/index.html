---
title: The Perils of Overly Local Optimization
author: Dylan O'Connell
date: '2020-05-27'
slug: local-optimization
categories: []
tags:
  - introductory
  - R
  - optimization
subtitle: ''
summary: ''
authors: []
lastmod: '2020-05-27T18:47:28-04:00'
featured: no
image:
  caption: ''
  focal_point: ''
  preview_only: no
projects: []
---



<pre class="r"><code>library(tidyverse)</code></pre>
<pre><code>## Registered S3 method overwritten by &#39;rvest&#39;:
##   method            from
##   read_xml.response xml2</code></pre>
<pre><code>## ── Attaching packages ───────────────────────────── tidyverse 1.2.1 ──</code></pre>
<pre><code>## ✓ ggplot2 3.2.1     ✓ purrr   0.3.4
## ✓ tibble  2.1.1     ✓ dplyr   0.8.3
## ✓ tidyr   0.8.3     ✓ stringr 1.4.0
## ✓ readr   1.3.1     ✓ forcats 0.4.0</code></pre>
<pre><code>## Warning: package &#39;purrr&#39; was built under R version 3.6.2</code></pre>
<pre><code>## ── Conflicts ──────────────────────────────── tidyverse_conflicts() ──
## x dplyr::filter() masks stats::filter()
## x dplyr::lag()    masks stats::lag()</code></pre>
<pre class="r"><code>library(gganimate)
library(transformr)
library(gifski)
### Maybe it&#39;s best to first start one-dimensional, before biting off more 
# than I can chew...


location.params &lt;- c(-10, 0, 10)
scale.params &lt;- c(3.5, 3, 4)
weights &lt;- c(.2, .4, .4)

CauchyMixtureDensity &lt;- function(x,
                                 location.params,
                                 shape.params,
                                 weights) {
  densities &lt;- map2(location.params, 
                    scale.params, 
                    function(.loc, .scale) dcauchy(x,
                                                   location = .loc, 
                                                   scale = .scale)) 
  return(do.call(cbind, densities) %*% weights)
}


DerivCauchy &lt;- function(x, location, scale) {
  2*(location-x)/(scale^3*pi*(1+(-location+x)^2/scale^2)^2)
}

CauchyMixtureDerivative &lt;- function(x,
                                    location.params,
                                    shape.params,
                                    weights) {
  densities &lt;- map2(location.params, 
                    scale.params, 
                    function(.loc, .scale) DerivCauchy(x,
                                                       location = .loc, 
                                                       scale = .scale)) 
  return(do.call(cbind, densities) %*% weights)
}

# Scalar for gradient ascent
x.init &lt;- 18

GradientAscentStep &lt;- function(x, 
                               eta, 
                               location.params, 
                               scale.params, 
                               weights,
                               type = &quot;Gradient Ascent&quot;) {
  deriv &lt;- CauchyMixtureDerivative(x, 
                                   location.params, 
                                   scale.params, 
                                   weights) %&gt;% 
    as.numeric()
  xprime &lt;- x + eta*deriv + ifelse(type == &quot;Noisy Ascent&quot;, 
                                   rnorm(1, 0, .5), 
                                   0)
  return(xprime)
}



RunGradientAscent &lt;- function(x.init, 
                              location.params,
                              scale.params,
                              weights,
                              eta,
                              type = &quot;Gradient&quot;) {
  max.iter &lt;- 10000
  ascent.seq &lt;- c(x.init)
  converged &lt;- FALSE
  i &lt;- 1
  while (! converged &amp;&amp; i &lt; max.iter) {
    ascent.seq[i+1] &lt;- GradientAscentStep(ascent.seq[i],
                                          eta,
                                          location.params,
                                          scale.params,
                                          weights,
                                          type)
    i &lt;- i + 1
    if (abs(ascent.seq[i] - ascent.seq[i-1])*100 &lt; 10^(-4)) {
      converged &lt;- TRUE
    }
  }
  return(ascent.seq)
}




###########
tb.dens.grid &lt;- tibble(x = seq(-20, 20, .1)) %&gt;%
  mutate(y = as.numeric(CauchyMixtureDensity(x, 
                                             location.params, 
                                             scale.params, 
                                             weights)))
eta.grad.ascent &lt;- 100
grad.ascent.seq &lt;- RunGradientAscent(x.init, 
                                     location.params,
                                     scale.params,
                                     weights,
                                     eta = eta.grad.ascent, 
                                     type = &quot;Gradient Ascent&quot;)</code></pre>
<pre class="r"><code>tb.grad.ascent &lt;- tibble(x = grad.ascent.seq,
                         iter = seq_along(grad.ascent.seq)) %&gt;%
  arrange(iter) %&gt;%
  # mutate(x.next = lead(x, n = 1, default = NA)) %&gt;%
  mutate(y = as.numeric(CauchyMixtureDensity(x, 
                                             location.params, 
                                             scale.params, 
                                             weights)),
         # y.next = as.numeric(CauchyMixtureDensity(x.next, 
         #                                          location.params, 
         #                                          scale.params, 
         #                                          weights)),
         grad = as.numeric(CauchyMixtureDerivative(x, 
                                                   location.params, 
                                                   scale.params, 
                                                   weights)),
         x.next = x + eta.grad.ascent*grad,
         y.next = as.numeric(CauchyMixtureDensity(x.next, 
                                                  location.params, 
                                                  scale.params, 
                                                  weights)))
p.ascent &lt;- ggplot(tb.dens.grid, aes(x = x, y = y)) + 
  geom_line() +
  geom_point(data = tb.grad.ascent, 
             col = &quot;red&quot;, size = 1) +
  geom_segment(data = tb.grad.ascent,
               aes(x = x, y = y, xend = x.next, yend = y.next),
               col = &quot;red&quot;, size = .25,
               arrow = arrow(length = unit(.2, &quot;cm&quot;), type = &quot;closed&quot;))  
p.ascent</code></pre>
<p><img src="/post/2020-05-27-local-optimization.en/index_files/figure-html/unnamed-chunk-2-1.png" width="672" /></p>
<pre class="r"><code>anim.ascent &lt;- p.ascent + transition_states(iter,
                                            transition_length = 1,
                                            state_length = 1)
animate(anim.ascent, 
        nframes = 10 + max(tb.grad.ascent$iter),
        renderer = gifski_renderer(&quot;test_grad_ascent_anim.gif&quot;))</code></pre>
<p><img src="/post/2020-05-27-local-optimization.en/index_files/figure-html/unnamed-chunk-2-1.gif" /><!-- -->
<img src="test_grad_ascent_anim.gif" /></p>
<pre class="r"><code>eta.noisy.ascent &lt;- 25
noisy.ascent.seq &lt;- RunGradientAscent(x.init, 
                                      location.params,
                                      scale.params,
                                      weights,
                                      eta = eta.noisy.ascent, 
                                      type = &quot;Noisy Ascent&quot;)


tb.noisy.ascent &lt;- tibble(x = noisy.ascent.seq,
                          iter = seq_along(noisy.ascent.seq)) %&gt;%
  arrange(iter) %&gt;%
  # mutate(x.next = lead(x, n = 1, default = NA)) %&gt;%
  mutate(y = as.numeric(CauchyMixtureDensity(x, 
                                             location.params, 
                                             scale.params, 
                                             weights)),
         # y.next = as.numeric(CauchyMixtureDensity(x.next, 
         #                                          location.params, 
         #                                          scale.params, 
         #                                          weights)),
         grad = CauchyMixtureDerivative(x, 
                                        location.params, 
                                        scale.params, 
                                        weights),
         x.next = x + eta.grad.ascent*grad,
         y.next = as.numeric(CauchyMixtureDensity(x.next, 
                                                  location.params, 
                                                  scale.params, 
                                                  weights)))
# For now, only plot until it finds the max
true.max &lt;- max(tb.noisy.ascent$y)
first.time.max &lt;- tb.noisy.ascent %&gt;% 
  filter(y &gt; .99*true.max) %&gt;%
  arrange(iter) %&gt;%
  slice(1) %&gt;%
  pull(iter)
tb.noisy.ascent &lt;- tb.noisy.ascent %&gt;%
  slice(1:first.time.max)




p.noisy &lt;- ggplot(tb.dens.grid, aes(x = x, y = y)) + 
  geom_line() +
  geom_point(data = tb.noisy.ascent, 
             col = &quot;red&quot;, size = 1) +
  geom_segment(data = tb.noisy.ascent,
               aes(x = x, y = y, xend = x.next, yend = y.next),
               # aes(x = x, y = y, xend = x.next, yend = y.next),
               col = &quot;red&quot;, size = .25,
               arrow = arrow(length = unit(.2, &quot;cm&quot;), type = &quot;closed&quot;)) 
p.noisy</code></pre>
<p><img src="/post/2020-05-27-local-optimization.en/index_files/figure-html/unnamed-chunk-3-1.png" width="672" /></p>
<pre class="r"><code>anim.noisy &lt;- p.noisy + transition_states(iter,
                                          transition_length = 1,
                                          state_length = 1)
animate(anim.noisy, 
        nframes = 10 + max(tb.noisy.ascent$iter),
        renderer = gifski_renderer(&quot;test_noisy_ascent_anim.gif&quot;))</code></pre>
<p><img src="/post/2020-05-27-local-optimization.en/index_files/figure-html/unnamed-chunk-3-1.gif" /><!-- --></p>
<p><img src="test_noisy_ascent_anim.gif" /></p>
